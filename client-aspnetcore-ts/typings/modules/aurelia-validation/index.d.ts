// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/controller-validate-result.d.ts
declare module '~aurelia-validation/dist/amd/controller-validate-result' {
import { ValidateResult } from '~aurelia-validation/dist/amd/validate-result';
import { ValidateInstruction } from '~aurelia-validation/dist/amd/validate-instruction';
/**
 * The result of a call to the validation controller's validate method.
 */
export interface ControllerValidateResult {
    /**
     * Whether validation passed.
     */
    valid: boolean;
    /**
     * The validation result of every rule that was evaluated.
     */
    results: ValidateResult[];
    /**
     * The instruction passed to the controller's validate method.
     */
    instruction?: ValidateInstruction;
}
}
declare module 'aurelia-validation/dist/amd/controller-validate-result' {
export * from '~aurelia-validation/dist/amd/controller-validate-result';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/get-target-dom-element.d.ts
declare module '~aurelia-validation/dist/amd/get-target-dom-element' {
/**
 * Gets the DOM element associated with the data-binding. Most of the time it's
 * the binding.target but sometimes binding.target is an aurelia custom element,
 * or custom attribute which is a javascript "class" instance, so we need to use
 * the controller's container to retrieve the actual DOM element.
 */
export function getTargetDOMElement(binding: any, view: any): Element;
}
declare module 'aurelia-validation/dist/amd/get-target-dom-element' {
export * from '~aurelia-validation/dist/amd/get-target-dom-element';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/property-info.d.ts
declare module '~aurelia-validation/dist/amd/property-info' {
import { Expression } from 'aurelia-binding';
/**
 * Retrieves the object and property name for the specified expression.
 * @param expression The expression
 * @param source The scope
 */
export function getPropertyInfo(expression: Expression, source: any): {
    object: Object;
    propertyName: string;
} | null;
}
declare module 'aurelia-validation/dist/amd/property-info' {
export * from '~aurelia-validation/dist/amd/property-info';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/validate-binding-behavior-base.d.ts
declare module '~aurelia-validation/dist/amd/validate-binding-behavior-base' {
import { TaskQueue } from 'aurelia-task-queue';
import { ValidationController } from '~aurelia-validation/dist/amd/validation-controller';
import { validateTrigger } from '~aurelia-validation/dist/amd/validate-trigger';
/**
 * Binding behavior. Indicates the bound property should be validated.
 */
export abstract class ValidateBindingBehaviorBase {
    private taskQueue;
    constructor(taskQueue: TaskQueue);
    protected abstract getValidateTrigger(controller: ValidationController): validateTrigger;
    bind(binding: any, source: any, rulesOrController?: ValidationController | any, rules?: any): void;
    unbind(binding: any): void;
}
}
declare module 'aurelia-validation/dist/amd/validate-binding-behavior-base' {
export * from '~aurelia-validation/dist/amd/validate-binding-behavior-base';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/validate-binding-behavior.d.ts
declare module '~aurelia-validation/dist/amd/validate-binding-behavior' {
import { TaskQueue } from 'aurelia-task-queue';
import { ValidationController } from '~aurelia-validation/dist/amd/validation-controller';
import { validateTrigger } from '~aurelia-validation/dist/amd/validate-trigger';
import { ValidateBindingBehaviorBase } from '~aurelia-validation/dist/amd/validate-binding-behavior-base';
/**
 * Binding behavior. Indicates the bound property should be validated
 * when the validate trigger specified by the associated controller's
 * validateTrigger property occurs.
 */
export class ValidateBindingBehavior extends ValidateBindingBehaviorBase {
    static inject: typeof TaskQueue[];
    getValidateTrigger(controller: ValidationController): validateTrigger;
}
/**
 * Binding behavior. Indicates the bound property will be validated
 * manually, by calling controller.validate(). No automatic validation
 * triggered by data-entry or blur will occur.
 */
export class ValidateManuallyBindingBehavior extends ValidateBindingBehaviorBase {
    static inject: typeof TaskQueue[];
    getValidateTrigger(): validateTrigger;
}
/**
 * Binding behavior. Indicates the bound property should be validated
 * when the associated element blurs.
 */
export class ValidateOnBlurBindingBehavior extends ValidateBindingBehaviorBase {
    static inject: typeof TaskQueue[];
    getValidateTrigger(): validateTrigger;
}
/**
 * Binding behavior. Indicates the bound property should be validated
 * when the associated element is changed by the user, causing a change
 * to the model.
 */
export class ValidateOnChangeBindingBehavior extends ValidateBindingBehaviorBase {
    static inject: typeof TaskQueue[];
    getValidateTrigger(): validateTrigger;
}
/**
 * Binding behavior. Indicates the bound property should be validated
 * when the associated element blurs or is changed by the user, causing
 * a change to the model.
 */
export class ValidateOnChangeOrBlurBindingBehavior extends ValidateBindingBehaviorBase {
    static inject: typeof TaskQueue[];
    getValidateTrigger(): validateTrigger;
}
}
declare module 'aurelia-validation/dist/amd/validate-binding-behavior' {
export * from '~aurelia-validation/dist/amd/validate-binding-behavior';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/validate-instruction.d.ts
declare module '~aurelia-validation/dist/amd/validate-instruction' {
/**
 * Instructions for the validation controller's validate method.
 */
export interface ValidateInstruction {
    /**
     * The object to validate.
     */
    object: any;
    /**
     * The property to validate. Optional.
     */
    propertyName?: any;
    /**
     * The rules to validate. Optional.
     */
    rules?: any;
}
}
declare module 'aurelia-validation/dist/amd/validate-instruction' {
export * from '~aurelia-validation/dist/amd/validate-instruction';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/validate-result.d.ts
declare module '~aurelia-validation/dist/amd/validate-result' {
/**
 * The result of validating an individual validation rule.
 */
export class ValidateResult {
    rule: any;
    object: any;
    propertyName: string | null;
    valid: boolean;
    message: string | null;
    private static nextId;
    /**
     * A number that uniquely identifies the result instance.
     */
    id: number;
    /**
     * @param rule The rule associated with the result. Validator implementation specific.
     * @param object The object that was validated.
     * @param propertyName The name of the property that was validated.
     * @param error The error, if the result is a validation error.
     */
    constructor(rule: any, object: any, propertyName: string | null, valid: boolean, message?: string | null);
    toString(): string | null;
}
}
declare module 'aurelia-validation/dist/amd/validate-result' {
export * from '~aurelia-validation/dist/amd/validate-result';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/validate-trigger.d.ts
declare module '~aurelia-validation/dist/amd/validate-trigger' {
/**
 * Validation triggers.
 */
export enum validateTrigger {
    /**
     * Manual validation.  Use the controller's `validate()` and  `reset()` methods
     * to validate all bindings.
     */
    manual = 0,
    /**
     * Validate the binding when the binding's target element fires a DOM "blur" event.
     */
    blur = 1,
    /**
     * Validate the binding when it updates the model due to a change in the view.
     */
    change = 2,
    /**
     * Validate the binding when the binding's target element fires a DOM "blur" event and
     * when it updates the model due to a change in the view.
     */
    changeOrBlur = 3,
}
}
declare module 'aurelia-validation/dist/amd/validate-trigger' {
export * from '~aurelia-validation/dist/amd/validate-trigger';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/validation-controller.d.ts
declare module '~aurelia-validation/dist/amd/validation-controller' {
import { Binding } from 'aurelia-binding';
import { Validator } from '~aurelia-validation/dist/amd/validator';
import { validateTrigger } from '~aurelia-validation/dist/amd/validate-trigger';
import { ValidationRenderer } from '~aurelia-validation/dist/amd/validation-renderer';
import { ValidateResult } from '~aurelia-validation/dist/amd/validate-result';
import { ValidateInstruction } from '~aurelia-validation/dist/amd/validate-instruction';
import { ControllerValidateResult } from '~aurelia-validation/dist/amd/controller-validate-result';
/**
 * Orchestrates validation.
 * Manages a set of bindings, renderers and objects.
 * Exposes the current list of validation results for binding purposes.
 */
export class ValidationController {
    private validator;
    static inject: typeof Validator[];
    private bindings;
    private renderers;
    /**
     * Validation results that have been rendered by the controller.
     */
    private results;
    /**
     * Validation errors that have been rendered by the controller.
     */
    errors: ValidateResult[];
    /**
     *  Whether the controller is currently validating.
     */
    validating: boolean;
    private elements;
    private objects;
    /**
     * The trigger that will invoke automatic validation of a property used in a binding.
     */
    validateTrigger: validateTrigger;
    private finishValidating;
    constructor(validator: Validator);
    /**
     * Adds an object to the set of objects that should be validated when validate is called.
     * @param object The object.
     * @param rules Optional. The rules. If rules aren't supplied the Validator implementation will lookup the rules.
     */
    addObject(object: any, rules?: any): void;
    /**
     * Removes an object from the set of objects that should be validated when validate is called.
     * @param object The object.
     */
    removeObject(object: any): void;
    /**
     * Adds and renders an error.
     */
    addError(message: string, object: any, propertyName?: string | null): ValidateResult;
    /**
     * Removes and unrenders an error.
     */
    removeError(result: ValidateResult): void;
    /**
     * Adds a renderer.
     * @param renderer The renderer.
     */
    addRenderer(renderer: ValidationRenderer): void;
    /**
     * Removes a renderer.
     * @param renderer The renderer.
     */
    removeRenderer(renderer: ValidationRenderer): void;
    /**
     * Registers a binding with the controller.
     * @param binding The binding instance.
     * @param target The DOM element.
     * @param rules (optional) rules associated with the binding. Validator implementation specific.
     */
    registerBinding(binding: Binding, target: Element, rules?: any): void;
    /**
     * Unregisters a binding with the controller.
     * @param binding The binding instance.
     */
    unregisterBinding(binding: Binding): void;
    /**
     * Interprets the instruction and returns a predicate that will identify
     * relevant results in the list of rendered validation results.
     */
    private getInstructionPredicate(instruction?);
    /**
     * Validates and renders results.
     * @param instruction Optional. Instructions on what to validate. If undefined, all
     * objects and bindings will be validated.
     */
    validate(instruction?: ValidateInstruction): Promise<ControllerValidateResult>;
    /**
     * Resets any rendered validation results (unrenders).
     * @param instruction Optional. Instructions on what to reset. If unspecified all rendered results
     * will be unrendered.
     */
    reset(instruction?: ValidateInstruction): void;
    /**
     * Gets the elements associated with an object and propertyName (if any).
     */
    private getAssociatedElements({object, propertyName});
    private processResultDelta(kind, oldResults, newResults);
    /**
     * Validates the property associated with a binding.
     */
    validateBinding(binding: Binding): void;
    /**
     * Resets the results for a property associated with a binding.
     */
    resetBinding(binding: Binding): void;
}
}
declare module 'aurelia-validation/dist/amd/validation-controller' {
export * from '~aurelia-validation/dist/amd/validation-controller';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/validation-controller-factory.d.ts
declare module '~aurelia-validation/dist/amd/validation-controller-factory' {
import { Container } from 'aurelia-dependency-injection';
import { ValidationController } from '~aurelia-validation/dist/amd/validation-controller';
import { Validator } from '~aurelia-validation/dist/amd/validator';
/**
 * Creates ValidationController instances.
 */
export class ValidationControllerFactory {
    private container;
    static get(container: Container): ValidationControllerFactory;
    constructor(container: Container);
    /**
     * Creates a new controller instance.
     */
    create(validator?: Validator): ValidationController;
    /**
     * Creates a new controller and registers it in the current element's container so that it's
     * available to the validate binding behavior and renderers.
     */
    createForCurrentScope(validator?: Validator): ValidationController;
}
}
declare module 'aurelia-validation/dist/amd/validation-controller-factory' {
export * from '~aurelia-validation/dist/amd/validation-controller-factory';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/validation-errors-custom-attribute.d.ts
declare module '~aurelia-validation/dist/amd/validation-errors-custom-attribute' {
import { Lazy } from 'aurelia-dependency-injection';
import { ValidationController } from '~aurelia-validation/dist/amd/validation-controller';
import { ValidateResult } from '~aurelia-validation/dist/amd/validate-result';
import { ValidationRenderer, RenderInstruction } from '~aurelia-validation/dist/amd/validation-renderer';
export interface RenderedError {
    error: ValidateResult;
    targets: Element[];
}
export class ValidationErrorsCustomAttribute implements ValidationRenderer {
    private boundaryElement;
    private controllerAccessor;
    static inject: ({
        new (): Element;
        prototype: Element;
    } | Lazy)[];
    controller: ValidationController | null;
    errors: RenderedError[];
    private errorsInternal;
    constructor(boundaryElement: Element, controllerAccessor: () => ValidationController);
    sort(): void;
    interestingElements(elements: Element[]): Element[];
    render(instruction: RenderInstruction): void;
    bind(): void;
    unbind(): void;
}
}
declare module 'aurelia-validation/dist/amd/validation-errors-custom-attribute' {
export * from '~aurelia-validation/dist/amd/validation-errors-custom-attribute';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/validation-renderer-custom-attribute.d.ts
declare module '~aurelia-validation/dist/amd/validation-renderer-custom-attribute' {
export class ValidationRendererCustomAttribute {
    private container;
    private controller;
    private value;
    private renderer;
    created(view: any): void;
    bind(): void;
    unbind(): void;
}
}
declare module 'aurelia-validation/dist/amd/validation-renderer-custom-attribute' {
export * from '~aurelia-validation/dist/amd/validation-renderer-custom-attribute';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/validation-renderer.d.ts
declare module '~aurelia-validation/dist/amd/validation-renderer' {
import { ValidateResult } from '~aurelia-validation/dist/amd/validate-result';
/**
 * A result to render (or unrender) and the associated elements (if any)
 */
export interface ResultInstruction {
    /**
     * The validation result.
     */
    result: ValidateResult;
    /**
     * The associated elements (if any).
     */
    elements: Element[];
}
/**
 * Defines which validation results to render and which validation results to unrender.
 */
export interface RenderInstruction {
    /**
     * The "kind" of render instruction. Either 'validate' or 'reset'.
     */
    kind: 'validate' | 'reset';
    /**
     * The results to render.
     */
    render: ResultInstruction[];
    /**
     * The results to unrender.
     */
    unrender: ResultInstruction[];
}
/**
 * Renders validation results.
 */
export interface ValidationRenderer {
    /**
     * Render the validation results.
     * @param instruction The render instruction. Defines which results to render and which
     * results to unrender.
     */
    render(instruction: RenderInstruction): void;
}
}
declare module 'aurelia-validation/dist/amd/validation-renderer' {
export * from '~aurelia-validation/dist/amd/validation-renderer';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/validator.d.ts
declare module '~aurelia-validation/dist/amd/validator' {
import { ValidateResult } from '~aurelia-validation/dist/amd/validate-result';
/**
 * Validates objects and properties.
 */
export abstract class Validator {
    /**
     * Validates the specified property.
     * @param object The object to validate.
     * @param propertyName The name of the property to validate.
     * @param rules Optional. If unspecified, the implementation should lookup the rules for the
     * specified object. This may not be possible for all implementations of this interface.
     */
    abstract validateProperty(object: any, propertyName: string, rules?: any): Promise<ValidateResult[]>;
    /**
     * Validates all rules for specified object and it's properties.
     * @param object The object to validate.
     * @param rules Optional. If unspecified, the implementation should lookup the rules for the
     * specified object. This may not be possible for all implementations of this interface.
     */
    abstract validateObject(object: any, rules?: any): Promise<ValidateResult[]>;
    /**
     * Determines whether a rule exists in a set of rules.
     * @param rules The rules to search.
     * @parem rule The rule to find.
     */
    abstract ruleExists(rules: any, rule: any): boolean;
}
}
declare module 'aurelia-validation/dist/amd/validator' {
export * from '~aurelia-validation/dist/amd/validator';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/implementation/rule.d.ts
declare module '~aurelia-validation/dist/amd/implementation/rule' {
import { Expression } from 'aurelia-binding';
export type ValidationDisplayNameAccessor = () => string;
/**
 * Information related to a property that is the subject of validation.
 */
export interface RuleProperty {
    /**
     * The property name. null indicates the rule targets the object itself.
     */
    name: string | null;
    /**
     * The displayName of the property (or object).
     */
    displayName: string | ValidationDisplayNameAccessor | null;
}
/**
 * A rule definition. Associations a rule with a property or object.
 */
export interface Rule<TObject, TValue> {
    property: RuleProperty;
    condition: (value: TValue, object?: TObject) => boolean | Promise<boolean>;
    config: Object;
    when: ((object: TObject) => boolean) | null;
    messageKey: string;
    message: Expression | null;
    sequence: number;
    tag?: string;
}
}
declare module 'aurelia-validation/dist/amd/implementation/rule' {
export * from '~aurelia-validation/dist/amd/implementation/rule';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/implementation/rules.d.ts
declare module '~aurelia-validation/dist/amd/implementation/rules' {
import { Rule } from '~aurelia-validation/dist/amd/implementation/rule';
/**
 * Sets, unsets and retrieves rules on an object or constructor function.
 */
export class Rules {
    /**
     * The name of the property that stores the rules.
     */
    private static key;
    /**
     * Applies the rules to a target.
     */
    static set(target: any, rules: Rule<any, any>[][]): void;
    /**
     * Removes rules from a target.
     */
    static unset(target: any): void;
    /**
     * Retrieves the target's rules.
     */
    static get(target: any): Rule<any, any>[][] | null;
}
}
declare module 'aurelia-validation/dist/amd/implementation/rules' {
export * from '~aurelia-validation/dist/amd/implementation/rules';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/implementation/standard-validator.d.ts
declare module '~aurelia-validation/dist/amd/implementation/standard-validator' {
import { ViewResources } from 'aurelia-templating';
import { Validator } from '~aurelia-validation/dist/amd/validator';
import { ValidateResult } from '~aurelia-validation/dist/amd/validate-result';
import { Rule } from '~aurelia-validation/dist/amd/implementation/rule';
import { ValidationMessageProvider } from '~aurelia-validation/dist/amd/implementation/validation-messages';
/**
 * Validates.
 * Responsible for validating objects and properties.
 */
export class StandardValidator extends Validator {
    static inject: (typeof ViewResources | typeof ValidationMessageProvider)[];
    private messageProvider;
    private lookupFunctions;
    private getDisplayName;
    constructor(messageProvider: ValidationMessageProvider, resources: ViewResources);
    /**
     * Validates the specified property.
     * @param object The object to validate.
     * @param propertyName The name of the property to validate.
     * @param rules Optional. If unspecified, the rules will be looked up using the metadata
     * for the object created by ValidationRules....on(class/object)
     */
    validateProperty(object: any, propertyName: string, rules?: any): Promise<ValidateResult[]>;
    /**
     * Validates all rules for specified object and it's properties.
     * @param object The object to validate.
     * @param rules Optional. If unspecified, the rules will be looked up using the metadata
     * for the object created by ValidationRules....on(class/object)
     */
    validateObject(object: any, rules?: any): Promise<ValidateResult[]>;
    /**
     * Determines whether a rule exists in a set of rules.
     * @param rules The rules to search.
     * @parem rule The rule to find.
     */
    ruleExists(rules: Rule<any, any>[][], rule: Rule<any, any>): boolean;
    private getMessage(rule, object, value);
    private validateRuleSequence(object, propertyName, ruleSequence, sequence, results);
    private validate(object, propertyName, rules);
}
}
declare module 'aurelia-validation/dist/amd/implementation/standard-validator' {
export * from '~aurelia-validation/dist/amd/implementation/standard-validator';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/implementation/validation-messages.d.ts
declare module '~aurelia-validation/dist/amd/implementation/validation-messages' {
import { Expression } from 'aurelia-binding';
import { ValidationParser } from '~aurelia-validation/dist/amd/implementation/validation-parser';
export interface ValidationMessages {
    [key: string]: string;
}
/**
 * Dictionary of validation messages. [messageKey]: messageExpression
 */
export const validationMessages: ValidationMessages;
/**
 * Retrieves validation messages and property display names.
 */
export class ValidationMessageProvider {
    private parser;
    static inject: typeof ValidationParser[];
    constructor(parser: ValidationParser);
    /**
     * Returns a message binding expression that corresponds to the key.
     * @param key The message key.
     */
    getMessage(key: string): Expression;
    /**
     * Formulates a property display name using the property name and the configured
     * displayName (if provided).
     * Override this with your own custom logic.
     * @param propertyName The property name.
     */
    getDisplayName(propertyName: string, displayName?: string | null | Function): string;
}
}
declare module 'aurelia-validation/dist/amd/implementation/validation-messages' {
export * from '~aurelia-validation/dist/amd/implementation/validation-messages';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/implementation/validation-parser.d.ts
declare module '~aurelia-validation/dist/amd/implementation/validation-parser' {
import { Parser, Expression, AccessScope, Unparser } from 'aurelia-binding';
import { BindingLanguage } from 'aurelia-templating';
import { RuleProperty } from '~aurelia-validation/dist/amd/implementation/rule';
export type PropertyAccessor<TObject, TValue> = (object: TObject) => TValue;
export class ValidationParser {
    private parser;
    private bindinqLanguage;
    static inject: (typeof Parser | typeof BindingLanguage)[];
    private emptyStringExpression;
    private nullExpression;
    private undefinedExpression;
    private cache;
    constructor(parser: Parser, bindinqLanguage: BindingLanguage);
    parseMessage(message: string): Expression;
    parseProperty<TObject, TValue>(property: string | PropertyAccessor<TObject, TValue>): RuleProperty;
    private coalesce(part);
    private getAccessorExpression(fn);
}
export class MessageExpressionValidator extends Unparser {
    private originalMessage;
    static validate(expression: Expression, originalMessage: string): void;
    constructor(originalMessage: string);
    visitAccessScope(access: AccessScope): void;
}
}
declare module 'aurelia-validation/dist/amd/implementation/validation-parser' {
export * from '~aurelia-validation/dist/amd/implementation/validation-parser';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/implementation/validation-rules.d.ts
declare module '~aurelia-validation/dist/amd/implementation/validation-rules' {
import { Rule, RuleProperty } from '~aurelia-validation/dist/amd/implementation/rule';
import { ValidationParser, PropertyAccessor } from '~aurelia-validation/dist/amd/implementation/validation-parser';
import { ValidationDisplayNameAccessor } from '~aurelia-validation/dist/amd/implementation/rule';
/**
 * Part of the fluent rule API. Enables customizing property rules.
 */
export class FluentRuleCustomizer<TObject, TValue> {
    private fluentEnsure;
    private fluentRules;
    private parser;
    private rule;
    constructor(property: RuleProperty, condition: (value: TValue, object?: TObject) => boolean | Promise<boolean>, config: Object | undefined, fluentEnsure: FluentEnsure<TObject>, fluentRules: FluentRules<TObject, TValue>, parser: ValidationParser);
    /**
     * Validate subsequent rules after previously declared rules have
     * been validated successfully. Use to postpone validation of costly
     * rules until less expensive rules pass validation.
     */
    then(): this;
    /**
     * Specifies the key to use when looking up the rule's validation message.
     */
    withMessageKey(key: string): this;
    /**
     * Specifies rule's validation message.
     */
    withMessage(message: string): this;
    /**
     * Specifies a condition that must be met before attempting to validate the rule.
     * @param condition A function that accepts the object as a parameter and returns true
     * or false whether the rule should be evaluated.
     */
    when(condition: (object: TObject) => boolean): this;
    /**
     * Tags the rule instance, enabling the rule to be found easily
     * using ValidationRules.taggedRules(rules, tag)
     */
    tag(tag: string): this;
    /**
     * Target a property with validation rules.
     * @param property The property to target. Can be the property name or a property accessor function.
     */
    ensure<TValue2>(subject: string | ((model: TObject) => TValue2)): FluentRules<TObject, TValue2>;
    /**
     * Targets an object with validation rules.
     */
    ensureObject(): FluentRules<TObject, TObject>;
    /**
     * Rules that have been defined using the fluent API.
     */
    readonly rules: Rule<TObject, any>[][];
    /**
     * Applies the rules to a class or object, making them discoverable by the StandardValidator.
     * @param target A class or object.
     */
    on(target: any): FluentEnsure<TObject>;
    /**
     * Applies an ad-hoc rule function to the ensured property or object.
     * @param condition The function to validate the rule.
     * Will be called with two arguments, the property value and the object.
     * Should return a boolean or a Promise that resolves to a boolean.
     */
    satisfies(condition: (value: TValue, object?: TObject) => boolean | Promise<boolean>, config?: Object): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies a rule by name.
     * @param name The name of the custom or standard rule.
     * @param args The rule's arguments.
     */
    satisfiesRule(name: string, ...args: any[]): any;
    /**
     * Applies the "required" rule to the property.
     * The value cannot be null, undefined or whitespace.
     */
    required(): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "matches" rule to the property.
     * Value must match the specified regular expression.
     * null, undefined and empty-string values are considered valid.
     */
    matches(regex: RegExp): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "email" rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    email(): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "minLength" STRING validation rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    minLength(length: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "maxLength" STRING validation rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    maxLength(length: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "minItems" ARRAY validation rule to the property.
     * null and undefined values are considered valid.
     */
    minItems(count: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "maxItems" ARRAY validation rule to the property.
     * null and undefined values are considered valid.
     */
    maxItems(count: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "equals" validation rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    equals(expectedValue: TValue): FluentRuleCustomizer<TObject, TValue>;
}
/**
 * Part of the fluent rule API. Enables applying rules to properties and objects.
 */
export class FluentRules<TObject, TValue> {
    private fluentEnsure;
    private parser;
    private property;
    static customRules: {
        [name: string]: {
            condition: (value: any, object?: any, ...fluentArgs: any[]) => boolean | Promise<boolean>;
            argsToConfig?: (...args: any[]) => any;
        };
    };
    /**
     * Current rule sequence number. Used to postpone evaluation of rules until rules
     * with lower sequence number have successfully validated. The "then" fluent API method
     * manages this property, there's usually no need to set it directly.
     */
    sequence: number;
    constructor(fluentEnsure: FluentEnsure<TObject>, parser: ValidationParser, property: RuleProperty);
    /**
     * Sets the display name of the ensured property.
     */
    displayName(name: string | ValidationDisplayNameAccessor | null): this;
    /**
     * Applies an ad-hoc rule function to the ensured property or object.
     * @param condition The function to validate the rule.
     * Will be called with two arguments, the property value and the object.
     * Should return a boolean or a Promise that resolves to a boolean.
     */
    satisfies(condition: (value: TValue, object?: TObject) => boolean | Promise<boolean>, config?: Object): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies a rule by name.
     * @param name The name of the custom or standard rule.
     * @param args The rule's arguments.
     */
    satisfiesRule(name: string, ...args: any[]): any;
    /**
     * Applies the "required" rule to the property.
     * The value cannot be null, undefined or whitespace.
     */
    required(): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "matches" rule to the property.
     * Value must match the specified regular expression.
     * null, undefined and empty-string values are considered valid.
     */
    matches(regex: RegExp): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "email" rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    email(): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "minLength" STRING validation rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    minLength(length: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "maxLength" STRING validation rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    maxLength(length: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "minItems" ARRAY validation rule to the property.
     * null and undefined values are considered valid.
     */
    minItems(count: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "maxItems" ARRAY validation rule to the property.
     * null and undefined values are considered valid.
     */
    maxItems(count: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "equals" validation rule to the property.
     * null and undefined values are considered valid.
     */
    equals(expectedValue: TValue): FluentRuleCustomizer<TObject, TValue>;
}
/**
 * Part of the fluent rule API. Enables targeting properties and objects with rules.
 */
export class FluentEnsure<TObject> {
    private parser;
    /**
     * Rules that have been defined using the fluent API.
     */
    rules: Rule<TObject, any>[][];
    constructor(parser: ValidationParser);
    /**
     * Target a property with validation rules.
     * @param property The property to target. Can be the property name or a property accessor
     * function.
     */
    ensure<TValue>(property: string | PropertyAccessor<TObject, TValue>): FluentRules<TObject, TValue>;
    /**
     * Targets an object with validation rules.
     */
    ensureObject(): FluentRules<TObject, TObject>;
    /**
     * Applies the rules to a class or object, making them discoverable by the StandardValidator.
     * @param target A class or object.
     */
    on(target: any): this;
    private assertInitialized();
}
/**
 * Fluent rule definition API.
 */
export class ValidationRules {
    private static parser;
    static initialize(parser: ValidationParser): void;
    /**
     * Target a property with validation rules.
     * @param property The property to target. Can be the property name or a property accessor function.
     */
    static ensure<TObject, TValue>(property: string | PropertyAccessor<TObject, TValue>): FluentRules<TObject, TValue>;
    /**
     * Targets an object with validation rules.
     */
    static ensureObject<TObject>(): FluentRules<TObject, TObject>;
    /**
     * Defines a custom rule.
     * @param name The name of the custom rule. Also serves as the message key.
     * @param condition The rule function.
     * @param message The message expression
     * @param argsToConfig A function that maps the rule's arguments to a "config"
     * object that can be used when evaluating the message expression.
     */
    static customRule(name: string, condition: (value: any, object?: any, ...args: any[]) => boolean | Promise<boolean>, message: string, argsToConfig?: (...args: any[]) => any): void;
    /**
     * Returns rules with the matching tag.
     * @param rules The rules to search.
     * @param tag The tag to search for.
     */
    static taggedRules(rules: Rule<any, any>[][], tag: string): Rule<any, any>[][];
    /**
     * Removes the rules from a class or object.
     * @param target A class or object.
     */
    static off(target: any): void;
}
}
declare module 'aurelia-validation/dist/amd/implementation/validation-rules' {
export * from '~aurelia-validation/dist/amd/implementation/validation-rules';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/master/dist/amd/aurelia-validation.d.ts
declare module '~aurelia-validation/dist/amd/aurelia-validation' {
export * from '~aurelia-validation/dist/amd/controller-validate-result';
export * from '~aurelia-validation/dist/amd/get-target-dom-element';
export * from '~aurelia-validation/dist/amd/property-info';
export * from '~aurelia-validation/dist/amd/validate-binding-behavior';
export * from '~aurelia-validation/dist/amd/validate-instruction';
export * from '~aurelia-validation/dist/amd/validate-result';
export * from '~aurelia-validation/dist/amd/validate-trigger';
export * from '~aurelia-validation/dist/amd/validation-controller';
export * from '~aurelia-validation/dist/amd/validation-controller-factory';
export * from '~aurelia-validation/dist/amd/validation-errors-custom-attribute';
export * from '~aurelia-validation/dist/amd/validation-renderer-custom-attribute';
export * from '~aurelia-validation/dist/amd/validation-renderer';
export * from '~aurelia-validation/dist/amd/validator';
export * from '~aurelia-validation/dist/amd/implementation/rule';
export * from '~aurelia-validation/dist/amd/implementation/rules';
export * from '~aurelia-validation/dist/amd/implementation/standard-validator';
export * from '~aurelia-validation/dist/amd/implementation/validation-messages';
export * from '~aurelia-validation/dist/amd/implementation/validation-parser';
export * from '~aurelia-validation/dist/amd/implementation/validation-rules';
import { Container } from 'aurelia-dependency-injection';
import { Validator } from '~aurelia-validation/dist/amd/validator';
/**
 * Aurelia Validation Configuration API
 */
export class AureliaValidationConfiguration {
    private validatorType;
    /**
     * Use a custom Validator implementation.
     */
    customValidator(type: {
        new (...args: any[]): Validator;
    }): void;
    /**
     * Applies the configuration.
     */
    apply(container: Container): void;
}
/**
 * Configures the plugin.
 */
export function configure(frameworkConfig: {
    container: Container;
    globalResources?: (...resources: string[]) => any;
}, callback?: (config: AureliaValidationConfiguration) => void): void;
}
declare module 'aurelia-validation/dist/amd/aurelia-validation' {
export * from '~aurelia-validation/dist/amd/aurelia-validation';
}
declare module 'aurelia-validation' {
export * from '~aurelia-validation/dist/amd/aurelia-validation';
}
